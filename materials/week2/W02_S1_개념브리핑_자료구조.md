# 2주차 — **파이썬 기초 ②:** 자료구조

## 세션 A: **개념 브리핑**(Concept Briefing)

---

## 학습 목표

1. 파이썬의 4대 핵심 **자료구조**(Data Structure)인 **리스트**(List), **튜플**(Tuple), **딕셔너리**(Dictionary), **집합**(Set)의 특성과 차이를 이해한다.
2. 각 자료구조의 생성, 접근, 변경 방법을 익힌다.
3. 실전 데이터(코로나19 확진자 수)를 자료구조에 담아 조작하는 감각을 기른다.

---

## 활용 데이터

**코로나19**(COVID-19) — 국가별·일별 확진자 수 데이터 (Our World in Data)

---

## 1. 왜 **자료구조**(Data Structure)를 배우는가?

1주차에서는 변수 하나에 값 하나를 저장하였다. 그러나 현실 데이터는 "여러 개의 값"을 한꺼번에 다뤄야 한다. 예를 들어, 7일간 확진자 수를 변수 7개에 따로 담으면 관리가 불가능하다. **자료구조**는 여러 데이터를 하나의 변수에 체계적으로 저장하는 방법이다.

> 비유: 변수가 "서랍 한 칸"이라면, 자료구조는 "서랍장 전체"이다.

---

## 2. 4대 자료구조 한눈에 비교

| 특성 | **리스트**(List) | **튜플**(Tuple) | **딕셔너리**(Dict) | **집합**(Set) |
|---|---|---|---|---|
| 기호 | `[ ]` | `( )` | `{ key: value }` | `{ }` |
| 순서 유지 | ✅ | ✅ | ✅ (3.7+) | ❌ |
| 변경 가능 | ✅ | ❌ | ✅ | ✅ |
| 중복 허용 | ✅ | ✅ | 키 ❌ / 값 ✅ | ❌ |
| 인덱싱 | ✅ | ✅ | 키로 접근 | ❌ |
| 대표 용도 | 순서가 있는 데이터 모음 | 변하면 안 되는 데이터 | 이름-값 매핑 | 중복 제거·집합 연산 |

> **핵심 암기법 — "리변튜불 딕키셋중"**
> - **리**스트는 **변**경 가능
> - **튜**플은 **불**변
> - **딕**셔너리는 **키**로 접근
> - **셋**은 **중**복 제거

---

## 3. **리스트**(List)

### 3.1 개념

**리스트**는 순서가 있고 변경이 가능한 자료구조이다. 대괄호 `[]`로 생성하며, 모든 자료형을 요소로 담을 수 있다.

```
시각화: 리스트의 메모리 구조

인덱스:   0       1       2       3       4
       ┌───────┬───────┬───────┬───────┬───────┐
 값:   │  100  │  250  │  180  │  310  │  275  │
       └───────┴───────┴───────┴───────┴───────┘
         ↑                                 ↑
     첫 번째 요소                    마지막 요소
     (index 0)                     (index -1)
```

### 3.2 생성과 접근

```python
# 리스트 생성
daily_cases = [100, 250, 180, 310, 275]

# 인덱싱
print(daily_cases[0])     # 100 — 첫 번째 요소
print(daily_cases[-1])    # 275 — 마지막 요소

# 슬라이싱
print(daily_cases[1:4])   # [250, 180, 310] — 1번~3번 인덱스
print(daily_cases[:3])    # [100, 250, 180] — 처음~2번 인덱스
```

### 3.3 주요 **메서드**(Method)

| **메서드**(Method) | 기능 | 예시 |
|---|---|---|
| `append(x)` | 맨 뒤에 요소 추가 | `daily_cases.append(400)` |
| `extend(리스트)` | 다른 리스트를 이어 붙이기 | `daily_cases.extend([500, 600])` |
| `insert(i, x)` | i번 위치에 x 삽입 | `daily_cases.insert(0, 50)` |
| `remove(x)` | 값 x를 찾아 삭제 | `daily_cases.remove(180)` |
| `pop(i)` | i번 요소를 꺼내고 삭제 | `daily_cases.pop(2)` |
| `sort()` | 오름차순 정렬(원본 변경) | `daily_cases.sort()` |
| `sorted(리스트)` | 정렬된 새 리스트 반환 | `sorted(daily_cases)` |
| `reverse()` | 순서 뒤집기 | `daily_cases.reverse()` |
| `count(x)` | x의 개수 반환 | `daily_cases.count(100)` |
| `index(x)` | x의 인덱스 반환 | `daily_cases.index(310)` |
| `len(리스트)` | 길이 반환 | `len(daily_cases)` |
| `sum(리스트)` | 합계 반환 | `sum(daily_cases)` |

### 3.4 **리스트 연산**(List Operation)

```python
a = [1, 2, 3]
b = [4, 5, 6]

print(a + b)    # [1, 2, 3, 4, 5, 6] — 연결
print(a * 3)    # [1, 2, 3, 1, 2, 3, 1, 2, 3] — 반복
```

### 3.5 **중첩 리스트**(Nested List)

리스트 안에 리스트를 넣을 수 있다. 이는 "표"와 유사한 2차원 데이터를 표현할 때 유용하다.

```python
# 국가별 3일간 확진자 수
covid_data = [
    ["한국",  100, 150, 120],
    ["미국", 5000, 6200, 5800],
    ["일본",  300,  280,  350]
]

print(covid_data[0])       # ["한국", 100, 150, 120]
print(covid_data[0][0])    # "한국"
print(covid_data[1][2])    # 6200
```

```
시각화: 중첩 리스트 구조

covid_data
  ├── [0] → ["한국", 100, 150, 120]
  │           [0]    [1]  [2]  [3]
  ├── [1] → ["미국", 5000, 6200, 5800]
  │           [0]    [1]   [2]   [3]
  └── [2] → ["일본", 300, 280, 350]
              [0]    [1]  [2]  [3]
```

---

## 4. **튜플**(Tuple)

### 4.1 개념

**튜플**은 순서가 있지만 변경이 불가능한(**불변**, Immutable) 자료구조이다. 소괄호 `()`로 생성한다.

### 4.2 리스트와의 차이

```python
# 리스트 — 변경 가능
my_list = [1, 2, 3]
my_list[0] = 100  # ✅ 가능

# 튜플 — 변경 불가
my_tuple = (1, 2, 3)
my_tuple[0] = 100  # ❌ TypeError 발생!
```

### 4.3 왜 **튜플**을 사용하는가?

1. **변하면 안 되는 데이터**를 보호한다. 예: 위도·경도 좌표 `(37.5665, 126.9780)`
2. 딕셔너리의 **키**(Key)로 사용할 수 있다. (리스트는 불가)
3. 리스트보다 **메모리를 적게** 사용하고 **속도가 빠르다.**

### 4.4 **패킹**(Packing)과 **언패킹**(Unpacking)

```python
# 패킹 — 여러 값을 하나의 튜플로 묶기
coord = 37.5665, 126.9780  # 괄호 생략 가능
print(coord)               # (37.5665, 126.978)

# 언패킹 — 튜플의 값을 각각의 변수에 풀기
lat, lon = coord
print(lat)                 # 37.5665
print(lon)                 # 126.978
```

```
시각화: 패킹과 언패킹

  패킹(Packing)             언패킹(Unpacking)
  ┌─────┐ ┌──────┐         ┌──────────────┐
  │37.57│ │126.98│  ──→    │(37.57,126.98)│  ──→  lat=37.57
  └─────┘ └──────┘         └──────────────┘       lon=126.98
  개별 값들                   하나의 튜플            다시 개별 변수로
```

---

## 5. **딕셔너리**(Dictionary)

### 5.1 개념

**딕셔너리**는 **키**(Key)와 **값**(Value)의 쌍으로 이루어진 자료구조이다. 중괄호 `{}`와 콜론 `:`으로 생성한다.

> 비유: 전화번호부에서 "이름(키)"으로 "전화번호(값)"를 찾는 것과 같다.

```
시각화: 딕셔너리 구조

  키(Key)        값(Value)
  ┌──────┐      ┌──────┐
  │"한국" │ ──→ │ 5000 │
  ├──────┤      ├──────┤
  │"미국" │ ──→ │85000 │
  ├──────┤      ├──────┤
  │"일본" │ ──→ │15000 │
  └──────┘      └──────┘
```

### 5.2 생성과 접근

```python
# 딕셔너리 생성
covid_by_country = {
    "한국": 5000,
    "미국": 85000,
    "일본": 15000
}

# 값 접근 (키를 사용)
print(covid_by_country["한국"])    # 5000
print(covid_by_country.get("영국", 0))  # 0 (없으면 기본값 반환)
```

### 5.3 주요 **메서드**(Method)

| **메서드**(Method) | 기능 | 예시 |
|---|---|---|
| `keys()` | 모든 키 반환 | `covid_by_country.keys()` |
| `values()` | 모든 값 반환 | `covid_by_country.values()` |
| `items()` | (키, 값) 쌍 반환 | `covid_by_country.items()` |
| `get(key, default)` | 키의 값 반환(없으면 기본값) | `covid_by_country.get("영국", 0)` |
| `update(dict)` | 다른 딕셔너리 병합 | `covid_by_country.update({"영국": 30000})` |
| `pop(key)` | 키-값 쌍 삭제 후 값 반환 | `covid_by_country.pop("미국")` |

### 5.4 값 추가·수정·삭제

```python
# 추가
covid_by_country["영국"] = 30000

# 수정
covid_by_country["한국"] = 5500

# 삭제
del covid_by_country["일본"]
```

### 5.5 **중첩 딕셔너리**(Nested Dictionary)

```python
# 국가별 상세 정보
covid_detail = {
    "한국": {"확진자": 5000, "사망자": 50, "완치자": 4500},
    "미국": {"확진자": 85000, "사망자": 1200, "완치자": 70000}
}

print(covid_detail["한국"]["완치자"])   # 4500
```

```
시각화: 중첩 딕셔너리

covid_detail
  ├── "한국" ──→ { "확진자": 5000,
  │                "사망자": 50,
  │                "완치자": 4500 }
  │
  └── "미국" ──→ { "확진자": 85000,
                   "사망자": 1200,
                   "완치자": 70000 }
```

---

## 6. **집합**(Set)

### 6.1 개념

**집합**은 중복을 허용하지 않고, 순서가 없는 자료구조이다. 중괄호 `{}`로 생성하되, 콜론 없이 값만 나열한다.

### 6.2 핵심 특성

```python
# 중복 자동 제거
numbers = {1, 2, 2, 3, 3, 3}
print(numbers)   # {1, 2, 3}

# 리스트의 중복 제거에 활용
daily = [100, 200, 100, 300, 200]
unique = list(set(daily))
print(unique)    # [100, 200, 300] (순서는 보장되지 않음)
```

### 6.3 **집합 연산**(Set Operation)

```python
A = {"한국", "미국", "일본", "영국"}    # 확진자 급증 국가
B = {"미국", "영국", "프랑스", "독일"}  # 사망자 급증 국가

print(A | B)    # 합집합: {"한국","미국","일본","영국","프랑스","독일"}
print(A & B)    # 교집합: {"미국","영국"}
print(A - B)    # 차집합: {"한국","일본"}
print(A ^ B)    # 대칭차집합: {"한국","일본","프랑스","독일"}
```

```
시각화: 집합 연산 벤 다이어그램

       A (확진자 급증)          B (사망자 급증)
    ┌─────────────────────────────────────┐
    │          ┌─────────────┐            │
    │  한국    │  미국  영국  │  프랑스    │
    │  일본    │  (교집합)    │  독일      │
    │          └─────────────┘            │
    └─────────────────────────────────────┘
         A - B      A & B       B - A
```

### 6.4 주요 **메서드**(Method)

| **메서드**(Method) | 기능 | 기호 연산자 |
|---|---|---|
| `union(B)` | **합집합** | `A \| B` |
| `intersection(B)` | **교집합** | `A & B` |
| `difference(B)` | **차집합** | `A - B` |
| `symmetric_difference(B)` | **대칭차집합** | `A ^ B` |
| `issubset(B)` | A가 B의 부분집합인가? | `A <= B` |
| `add(x)` | 요소 추가 | — |
| `discard(x)` | 요소 삭제(없어도 에러 없음) | — |

---

## 7. **불리언**(Boolean) — 참과 거짓

**불리언**은 `True` 또는 `False` 두 가지 값만 가지는 자료형이다. 조건 판단과 논리 연산의 기초가 된다.

### 7.1 비교 연산자

| 연산자 | 의미 | 예시 | 결과 |
|---|---|---|---|
| `==` | 같다 | `3 == 3` | `True` |
| `!=` | 같지 않다 | `3 != 5` | `True` |
| `>` | 크다 | `5 > 3` | `True` |
| `<` | 작다 | `5 < 3` | `False` |
| `>=` | 크거나 같다 | `3 >= 3` | `True` |
| `<=` | 작거나 같다 | `5 <= 3` | `False` |

### 7.2 논리 연산자

| 연산자 | 의미 | 예시 | 결과 |
|---|---|---|---|
| `and` | 둘 다 참이면 참 | `True and False` | `False` |
| `or` | 하나라도 참이면 참 | `True or False` | `True` |
| `not` | 반대 | `not True` | `False` |

### 7.3 `in` / `not in` 연산자

```python
countries = ["한국", "미국", "일본"]
print("한국" in countries)       # True
print("영국" not in countries)   # True
```

---

## 8. **심화 개념:** `copy()`와 참조

리스트를 `=`로 복사하면, 실제로는 같은 메모리를 가리키게 된다. 독립적인 복사본을 만들려면 `copy()` 메서드를 사용해야 한다.

```python
a = [1, 2, 3]
b = a          # b는 a와 같은 객체를 가리킴
a[0] = 999
print(b)       # [999, 2, 3] — b도 바뀜!

a = [1, 2, 3]
c = a.copy()   # c는 독립적인 복사본
a[0] = 999
print(c)       # [1, 2, 3] — c는 영향 없음
```

```
시각화: 참조 복사 vs copy()

  a = [1,2,3]        a = [1,2,3]
  b = a               c = a.copy()

  a ──→ ┌───┬───┬───┐   a ──→ ┌───┬───┬───┐
        │ 1 │ 2 │ 3 │         │ 1 │ 2 │ 3 │
  b ──→ └───┴───┴───┘   c ──→ ┌───┬───┬───┐
  (같은 주소!)                  │ 1 │ 2 │ 3 │
                               └───┴───┴───┘
                        (다른 주소 — 독립!)
```

---

## 핵심 요약

1. **리스트**(List): 순서 ✅, 변경 ✅ → 가장 범용적인 자료구조이다.
2. **튜플**(Tuple): 순서 ✅, 변경 ❌ → 보호해야 할 데이터에 사용한다.
3. **딕셔너리**(Dictionary): 키-값 매핑 → 이름으로 데이터를 찾을 때 사용한다.
4. **집합**(Set): 중복 제거, 집합 연산 → 교집합·합집합 등이 필요할 때 사용한다.
5. **불리언**(Boolean): 참/거짓 → 조건 판단의 기초이다.
6. `copy()`를 사용해야 리스트의 독립적인 복사본을 만들 수 있다.

---

*다음 세션(세션 B)에서는 이 개념들을 코로나19 데이터에 직접 적용하는 **핑퐁 코딩**을 진행한다.*
